#!/usr/bin/env python3
from pathlib import Path
import sys, re

HISTORY = Path(sys.argv[1])
BACKUP = HISTORY.with_suffix(".bak")

MAX_CMD_LINES = 10
MAX_PATHS = 5


ENTRY_RE = re.compile(br'(?m)(?=^- cmd:)')  # multiline, zero-width


def split_entries(data: bytes):
    # Split on entry starts, keep content intact
    parts = ENTRY_RE.split(data)
    return [p for p in parts if p.strip()]


def parse_entry(entry: bytes):
    cmd = None
    path_count = 0

    lines = entry.split(b"\n")
    i = 0

    while i < len(lines):
        line = lines[i]

        if line.startswith(b"- cmd:"):
            cmd = line[len(b"- cmd:"):].lstrip()

        elif line.strip() == b"paths:":
            i += 1
            while i < len(lines) and lines[i].lstrip().startswith(b"- "):
                path_count += 1
                i += 1
            continue

        i += 1

    return cmd, path_count


def should_delete(cmd: bytes | None, path_count: int):
    if not cmd:
        return False

    # literal "\n" inside cmd value
    cmd_lines = cmd.count(b"\\n") + 1

    if cmd_lines >= MAX_CMD_LINES:
        return True

    if path_count > MAX_PATHS:
        return True

    return False


def main():
    data = HISTORY.read_bytes()
    BACKUP.write_bytes(data)
    print(f"Backup written to: {BACKUP}")

    entries = split_entries(data)

    kept = []
    removed = []

    for e in entries:
        cmd, path_count = parse_entry(e)
        if should_delete(cmd, path_count):
            removed.append(e)
        else:
            kept.append(e)

    # Preserve original newline layout between entries
    output = b"\n".join(k.rstrip(b"\n") for k in kept) + b"\n"
    HISTORY.write_bytes(output)

    print(f"Entries total: {len(entries)}")
    print(f"Kept: {len(kept)}")
    print(f"Removed: {len(removed)}")

    if removed:
        print("\nRemoved entries:")
        for e in removed:
            print("----")
            print(e.decode("utf-8", errors="replace"))


if __name__ == "__main__":
    main()
